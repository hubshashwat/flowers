<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Geode Flower | Flowers For You ðŸŒ¸</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="loading-overlay">
        <div class="loading-flower"></div>
        <p class="loading-text">Cracking open...</p>
    </div>

    <div class="flower-page">
        <nav class="page-nav">
            <a href="../index.html" class="back-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                </svg>
                Back to Garden
            </a>
        </nav>
        <div id="canvas-container" class="flower-canvas"></div>
        <div class="flower-info">
            <h1>Crystal Geode Flower</h1>
            <p>Rocky exterior cracks to reveal crystalline petals</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../js/utils.js"></script>
    <script>
        (function () {
            const container = document.getElementById('canvas-container');
            const { scene, camera, renderer, clock } = FlowerUtils.initScene(container, {
                background: 0x1a1515
            });

            renderer.toneMapping = THREE.ACESFilmicToneMapping;

            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0.5, 0);

            // Lighting
            const ambient = new THREE.AmbientLight(0x443344, 0.5);
            scene.add(ambient);
            const mainLight = new THREE.PointLight(0xaa88ff, 2, 10);
            mainLight.position.set(0, 2, 2);
            scene.add(mainLight);
            const backLight = new THREE.PointLight(0xff88aa, 1, 10);
            backLight.position.set(-2, 1, -2);
            scene.add(backLight);

            // Geode shell (two halves)
            const shellMat = new THREE.MeshStandardMaterial({
                color: 0x443333,
                roughness: 0.9,
                metalness: 0.1
            });

            // Create rough rock geometry
            function createRockHalf(isLeft) {
                const geom = new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI);
                const positions = geom.attributes.position;

                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const noise = (Math.random() - 0.5) * 0.1;
                    positions.setX(i, x + noise);
                    positions.setY(i, y + noise);
                    positions.setZ(i, z + noise);
                }
                positions.needsUpdate = true;
                geom.computeVertexNormals();

                const mesh = new THREE.Mesh(geom, shellMat);
                mesh.rotation.y = isLeft ? 0 : Math.PI;
                return mesh;
            }

            const leftShell = createRockHalf(true);
            leftShell.position.set(-0.1, 0.5, 0);
            scene.add(leftShell);

            const rightShell = createRockHalf(false);
            rightShell.position.set(0.1, 0.5, 0);
            scene.add(rightShell);

            // Crystal flower inside
            const crystalGroup = new THREE.Group();
            crystalGroup.position.y = 0.5;
            scene.add(crystalGroup);

            // Crystal material
            const crystalMat = new THREE.MeshPhysicalMaterial({
                color: 0xaa66ff,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.3,
                thickness: 0.5,
                transparent: true,
                opacity: 0.9
            });

            // Create crystal petals
            const petalCount = 8;
            const petals = [];
            for (let i = 0; i < petalCount; i++) {
                const geom = new THREE.ConeGeometry(0.08, 0.4, 6);
                const petal = new THREE.Mesh(geom, crystalMat.clone());
                petal.material.color.setHSL(0.75 + Math.random() * 0.1, 0.6, 0.6);

                const angle = (i / petalCount) * Math.PI * 2;
                petal.position.set(
                    Math.cos(angle) * 0.15,
                    0.1,
                    Math.sin(angle) * 0.15
                );
                petal.rotation.z = -angle;
                petal.rotation.x = -0.8;
                petal.scale.setScalar(0);
                crystalGroup.add(petal);
                petals.push(petal);
            }

            // Center crystal cluster
            for (let i = 0; i < 5; i++) {
                const geom = new THREE.OctahedronGeometry(0.04 + Math.random() * 0.03, 0);
                const crystal = new THREE.Mesh(geom, crystalMat.clone());
                crystal.material.color.setHSL(0.8, 0.7, 0.7);
                crystal.position.set(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                crystal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                crystalGroup.add(crystal);
                petals.push(crystal);
            }

            // Light rays (scattered from crystals)
            const rayCount = 20;
            const rays = [];
            for (let i = 0; i < rayCount; i++) {
                const rayGeom = new THREE.CylinderGeometry(0.002, 0.01, 1, 4);
                const rayMat = new THREE.MeshBasicMaterial({
                    color: 0xaa88ff,
                    transparent: true,
                    opacity: 0
                });
                const ray = new THREE.Mesh(rayGeom, rayMat);
                ray.position.set(0, 0.5, 0);
                ray.rotation.set(
                    Math.random() * Math.PI - Math.PI / 2,
                    Math.random() * Math.PI * 2,
                    0
                );
                scene.add(ray);
                rays.push(ray);
            }

            let openProgress = 0;
            let openDirection = 1;

            function animate() {
                requestAnimationFrame(animate);
                const elapsed = clock.getElapsedTime();

                // Open/close cycle
                openProgress += openDirection * 0.004;
                if (openProgress > 1) { openProgress = 1; openDirection = -1; }
                if (openProgress < 0) { openProgress = 0; openDirection = 1; }

                // Animate shells opening
                const shellOpen = openProgress * 0.8;
                leftShell.position.x = -0.1 - shellOpen * 0.5;
                leftShell.rotation.y = shellOpen * 0.5;
                rightShell.position.x = 0.1 + shellOpen * 0.5;
                rightShell.rotation.y = Math.PI - shellOpen * 0.5;

                // Reveal crystals
                petals.forEach((petal, i) => {
                    const delay = i * 0.05;
                    const crystalProgress = Math.max(0, Math.min(1, (openProgress - 0.3 - delay) * 2));
                    petal.scale.setScalar(crystalProgress);
                });

                // Light rays appear
                rays.forEach((ray, i) => {
                    const rayProgress = Math.max(0, (openProgress - 0.5) * 3);
                    ray.material.opacity = rayProgress * 0.3 * Math.abs(Math.sin(elapsed * 2 + i));
                    ray.rotation.z += 0.01;
                });

                // Crystal glow
                mainLight.intensity = 1 + openProgress * 2;

                crystalGroup.rotation.y = elapsed * 0.1;

                camera.position.x = Math.sin(elapsed * 0.1) * 0.5;
                camera.lookAt(0, 0.5, 0);

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            FlowerUtils.hideLoading();
        })();
    </script>
</body>

</html>