<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meteor Flower | Flowers For You ðŸŒ¸</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="loading-overlay">
        <div class="loading-flower"></div>
        <p class="loading-text">Streaking through space...</p>
    </div>

    <div class="flower-page">
        <nav class="page-nav">
            <a href="../index.html" class="back-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                </svg>
                Back to Garden
            </a>
        </nav>
        <div id="canvas-container" class="flower-canvas"></div>
        <div class="flower-info">
            <h1>Meteor Flower</h1>
            <p>Cosmic flower streaking through space with a luminous trail</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../js/utils.js"></script>
    <script>
        (function () {
            const container = document.getElementById('canvas-container');
            const { scene, camera, renderer, clock } = FlowerUtils.initScene(container, {
                background: 0x000008
            });

            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);

            // Starfield
            const starCount = 500;
            const starGeom = new THREE.BufferGeometry();
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                starPos[i * 3] = (Math.random() - 0.5) * 20;
                starPos[i * 3 + 1] = (Math.random() - 0.5) * 20;
                starPos[i * 3 + 2] = (Math.random() - 0.5) * 20 - 5;
            }
            starGeom.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.02 });
            const stars = new THREE.Points(starGeom, starMat);
            scene.add(stars);

            // Flower group (the meteor)
            const meteorGroup = new THREE.Group();
            scene.add(meteorGroup);

            // Glowing flower material
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffaa66,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });

            // Create petals
            const petalCount = 6;
            const petals = [];
            for (let i = 0; i < petalCount; i++) {
                const shape = new THREE.Shape();
                shape.moveTo(0, 0);
                shape.bezierCurveTo(0.1, 0.05, 0.12, 0.25, 0.06, 0.4);
                shape.bezierCurveTo(0.02, 0.48, -0.02, 0.48, -0.06, 0.4);
                shape.bezierCurveTo(-0.12, 0.25, -0.1, 0.05, 0, 0);

                const geom = new THREE.ShapeGeometry(shape, 12);
                const petal = new THREE.Mesh(geom, glowMat.clone());
                const angle = (i / petalCount) * Math.PI * 2;
                petal.rotation.z = angle;
                petal.rotation.x = -Math.PI / 2 + 0.6;
                petal.userData.phase = i * 0.4;
                meteorGroup.add(petal);
                petals.push(petal);
            }

            // Center (bright core)
            const centerGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            const center = new THREE.Mesh(centerGeom, centerMat);
            meteorGroup.add(center);

            // Core glow
            const coreGlowGeom = new THREE.SphereGeometry(0.15, 16, 16);
            const coreGlowMat = new THREE.MeshBasicMaterial({
                color: 0xffaa44,
                transparent: true,
                opacity: 0.4
            });
            const coreGlow = new THREE.Mesh(coreGlowGeom, coreGlowMat);
            meteorGroup.add(coreGlow);

            // Meteor trail
            const trailCount = 80;
            const trailGeom = new THREE.BufferGeometry();
            const trailPos = new Float32Array(trailCount * 3);
            const trailColors = new Float32Array(trailCount * 3);
            for (let i = 0; i < trailCount; i++) {
                trailPos[i * 3] = -i * 0.05;
                trailPos[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                trailPos[i * 3 + 2] = (Math.random() - 0.5) * 0.1;

                const fade = 1 - i / trailCount;
                trailColors[i * 3] = 1;
                trailColors[i * 3 + 1] = 0.6 * fade;
                trailColors[i * 3 + 2] = 0.2 * fade;
            }
            trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
            trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
            const trailMat = new THREE.PointsMaterial({
                size: 0.04,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            const trail = new THREE.Points(trailGeom, trailMat);
            meteorGroup.add(trail);

            // Secondary sparkle trail
            const sparkleCount = 50;
            const sparkleGeom = new THREE.BufferGeometry();
            const sparklePos = new Float32Array(sparkleCount * 3);
            for (let i = 0; i < sparkleCount; i++) {
                sparklePos[i * 3] = -i * 0.08 + (Math.random() - 0.5) * 0.2;
                sparklePos[i * 3 + 1] = (Math.random() - 0.5) * 0.3;
                sparklePos[i * 3 + 2] = (Math.random() - 0.5) * 0.3;
            }
            sparkleGeom.setAttribute('position', new THREE.BufferAttribute(sparklePos, 3));
            const sparkleMat = new THREE.PointsMaterial({
                color: 0xffff88,
                size: 0.02,
                transparent: true,
                opacity: 0.6
            });
            const sparkles = new THREE.Points(sparkleGeom, sparkleMat);
            meteorGroup.add(sparkles);

            // Position meteor
            meteorGroup.rotation.z = 0.3;

            function animate() {
                requestAnimationFrame(animate);
                const elapsed = clock.getElapsedTime();

                // Meteor moves across screen (looping)
                const xPos = ((elapsed * 0.5) % 4) - 2;
                meteorGroup.position.x = xPos;

                // Petals flutter
                petals.forEach(petal => {
                    const flutter = Math.sin(elapsed * 8 + petal.userData.phase) * 0.1;
                    petal.rotation.x = -Math.PI / 2 + 0.6 + flutter;
                });

                // Core pulses
                const pulse = Math.sin(elapsed * 5) * 0.2 + 1;
                coreGlow.scale.setScalar(pulse);
                center.scale.setScalar(0.8 + pulse * 0.2);

                // Trail particles update
                const tPos = trailGeom.attributes.position.array;
                for (let i = 0; i < trailCount; i++) {
                    tPos[i * 3 + 1] += (Math.random() - 0.5) * 0.01;
                    tPos[i * 3 + 2] += (Math.random() - 0.5) * 0.01;
                }
                trailGeom.attributes.position.needsUpdate = true;

                // Sparkles shimmer
                const sPos = sparkleGeom.attributes.position.array;
                for (let i = 0; i < sparkleCount; i++) {
                    sPos[i * 3 + 1] += (Math.random() - 0.5) * 0.01;
                }
                sparkleGeom.attributes.position.needsUpdate = true;
                sparkleMat.opacity = 0.4 + Math.sin(elapsed * 10) * 0.2;

                // Stars move slowly (parallax)
                const sStars = starGeom.attributes.position.array;
                for (let i = 0; i < starCount; i++) {
                    sStars[i * 3] -= 0.005;
                    if (sStars[i * 3] < -10) sStars[i * 3] = 10;
                }
                starGeom.attributes.position.needsUpdate = true;

                // Slight bloom rotation
                meteorGroup.rotation.y = elapsed * 0.3;

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            FlowerUtils.hideLoading();
        })();
    </script>
</body>

</html>