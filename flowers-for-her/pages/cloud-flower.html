<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloud Flower | Flowers For You ðŸŒ¸</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="loading-overlay">
        <div class="loading-flower"></div>
        <p class="loading-text">Forming clouds...</p>
    </div>

    <div class="flower-page">
        <nav class="page-nav">
            <a href="../index.html" class="back-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                </svg>
                Back to Garden
            </a>
        </nav>
        <div id="canvas-container" class="flower-canvas"></div>
        <div class="flower-info">
            <h1>Cloud Flower</h1>
            <p>Volumetric wisps that dissipate and reform</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../js/utils.js"></script>
    <script>
        (function () {
            const container = document.getElementById('canvas-container');
            const { scene, camera, renderer, clock } = FlowerUtils.initScene(container, {
                background: 0x87ceeb
            });

            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0.5, 0);

            // Soft sky lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sunLight = new THREE.DirectionalLight(0xfffaee, 1);
            sunLight.position.set(5, 10, 5);
            scene.add(sunLight);

            // Cloud particle material
            const cloudTexture = new THREE.CanvasTexture(createCloudTexture());

            function createCloudTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                return canvas;
            }

            // Cloud flower structure
            const flowerGroup = new THREE.Group();
            scene.add(flowerGroup);

            // Create cloud puff
            function createCloudPuff(count, radius, color) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                const opacities = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = radius * (0.5 + Math.random() * 0.5);

                    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = r * Math.cos(phi);
                    positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                    sizes[i] = 0.1 + Math.random() * 0.15;
                    opacities[i] = 0.3 + Math.random() * 0.4;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: 0.2,
                    map: cloudTexture,
                    transparent: true,
                    opacity: 0.7,
                    depthWrite: false,
                    blending: THREE.NormalBlending
                });

                const cloud = new THREE.Points(geometry, material);
                cloud.userData.basePositions = positions.slice();
                cloud.userData.opacities = opacities;
                return cloud;
            }

            // Petals (cloud puffs arranged in flower shape)
            const petalCount = 6;
            const petals = [];
            for (let i = 0; i < petalCount; i++) {
                const petal = createCloudPuff(80, 0.25, 0xffffff);
                const angle = (i / petalCount) * Math.PI * 2;
                petal.position.set(
                    Math.cos(angle) * 0.35,
                    0.5,
                    Math.sin(angle) * 0.35
                );
                petal.userData.angle = angle;
                petal.userData.phase = i * 0.5;
                flowerGroup.add(petal);
                petals.push(petal);
            }

            // Center puff (slightly pink)
            const center = createCloudPuff(100, 0.2, 0xfff0f5);
            center.position.y = 0.5;
            flowerGroup.add(center);

            // Stem (thin cloud trail)
            const stemParticleCount = 50;
            const stemGeom = new THREE.BufferGeometry();
            const stemPos = new Float32Array(stemParticleCount * 3);
            for (let i = 0; i < stemParticleCount; i++) {
                stemPos[i * 3] = (Math.random() - 0.5) * 0.1;
                stemPos[i * 3 + 1] = -i * 0.025;
                stemPos[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
            }
            stemGeom.setAttribute('position', new THREE.BufferAttribute(stemPos, 3));
            const stemMat = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 0.08,
                map: cloudTexture,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const stem = new THREE.Points(stemGeom, stemMat);
            stem.position.y = 0.4;
            flowerGroup.add(stem);

            function animate() {
                requestAnimationFrame(animate);
                const elapsed = clock.getElapsedTime();

                // Animate cloud petals (turbulence)
                petals.forEach((petal, i) => {
                    const positions = petal.geometry.attributes.position.array;
                    const basePositions = petal.userData.basePositions;

                    for (let j = 0; j < positions.length; j += 3) {
                        const turbulence = 0.03;
                        positions[j] = basePositions[j] + Math.sin(elapsed * 2 + j) * turbulence;
                        positions[j + 1] = basePositions[j + 1] + Math.cos(elapsed * 1.5 + j * 0.5) * turbulence;
                        positions[j + 2] = basePositions[j + 2] + Math.sin(elapsed * 1.8 + j * 0.3) * turbulence;
                    }
                    petal.geometry.attributes.position.needsUpdate = true;

                    // Petal opacity cycle (dissipate and reform)
                    const cycle = Math.sin(elapsed * 0.5 + petal.userData.phase) * 0.5 + 0.5;
                    petal.material.opacity = 0.4 + cycle * 0.4;

                    // Slight movement
                    petal.position.y = 0.5 + Math.sin(elapsed + petal.userData.phase) * 0.05;
                });

                // Center turbulence
                const centerPos = center.geometry.attributes.position.array;
                const centerBase = center.userData.basePositions;
                for (let j = 0; j < centerPos.length; j += 3) {
                    centerPos[j] = centerBase[j] + Math.sin(elapsed * 2.5 + j * 0.1) * 0.02;
                    centerPos[j + 1] = centerBase[j + 1] + Math.cos(elapsed * 2 + j * 0.15) * 0.02;
                    centerPos[j + 2] = centerBase[j + 2] + Math.sin(elapsed * 1.5 + j * 0.2) * 0.02;
                }
                center.geometry.attributes.position.needsUpdate = true;

                flowerGroup.rotation.y = elapsed * 0.1;

                camera.position.x = Math.sin(elapsed * 0.08) * 0.5;
                camera.lookAt(0, 0.5, 0);

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
            FlowerUtils.hideLoading();
        })();
    </script>
</body>

</html>